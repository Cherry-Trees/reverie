start:
    | fns?

fns:
    | fn (";" fn)

fn:
    | "fn" name param? "=" expr

fn f(x: Int) -> Int = {

}

ident:
    | name (":" type)?

type:
    | name

param:
    | name
    | "(" names? ")"

names:
    | name ("," name)*

name:
    | alpha (alpha | digit)*

let x = 5;
l = [1 ; 3 ; 4];
l ! 0 = 10;
print l;

exprs:
    | expr (";" expr)*

expr:
    | "let" ident "=" expr
    | or_expr ("=" expr)?

x = 5;


bind_expr:
    | or_expr (bind_op or_expr)*

or_expr:
    | and_expr (or_op and_expr)*

and_expr:
    | eq_expr (and_op eq_expr)*

eq_expr:
    | rel_expr (eq_op rel_expr)*

rel_expr:
    | add_expr (rel_op add_expr)*

add_expr:
    | mul_expr (add_op mul_expr)*

mul_expr:
    | unary_expr (mul_op unary_expr)*

unary_expr:
    | (pre_unary_op)* atom (post_unary_op)*

or_op:
    | "||"

and_op:
    | "&&"

eq_op:
    | "=="
    | "!="

rel_op:
    | "<"
    | "<="
    | ">"
    | ">="

add_op:
    | "+"
    | "-"

mul_op:
    | "*"
    | "/"
    | "%"

pre_unary_op:
    | "-"
    | "~"

post_unary_op:
    | "!"

print!(4);

atom:
    | prim
    | var
    | str
    | list
    | tuple
    | block
    | lambda
    | if
    | for

prim:
    | float 
    | int
    | char
    | bool
    | none

float:
    | digit+ "." digit+

int:
    | digit+

char:
    | "'" . "'" 

bool:
    | "True"
    | "False"

none:
    | "None"



f x = x + 2;

f(x) = x + 2;

have a map of expression trees for pattern matching/set of mappings (tuples)'





r = (1,2);
f!r;
fn printFive: None = print! 5
;

fn main -> None = printFive! 
;


f : R -> R -> R
f = x -> y -> x + y


f : R -> (R -> R) -> R
f = x -> g -> g x

var:
    | name ("!" expr?)?

str:
    | """ .* """

list:
    | "[" exprs? "]"

tuple:
    | "(" exprs? ")"

block:
    | "{" exprs? "}"

f = const 5;

lambda:
    | "const" expr
    | 

if:
    | "if" expr "then" expr ("else" expr)?

for:
    | expr "for" name "in" expr ("if" expr)?

while:
    | "while" expr "do" expr

